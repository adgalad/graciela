
/*% LANGUAGE MemoryOperations  %*/
/*% LANGUAGE EnableTrace  %*/

include "chao"

module String begin

  enum T_T {
    A := -100,
    B, 
    C,
    D := 10,
    E,
    F,
    G := 20,
    H
  }

  abstract StringA begin
    /* asd variables */
    var a_str : sequence of char;
    {repinv #a_str >= 0 repinv}
    /* asd procedures and functions */
    proc concat(in str1 : StringA, in str2 : StringA, inout str_out : StringA)
      {pre true  pre}
      {post str_out.a_str == str1.a_str ++ str2.a_str post}
  end

  type String implements StringA begin
    /* String variables */
    var size : int;
    var s    : char*;
    
    {repinv true repinv}

    {coupinv true coupinv}

    where {
      a_str := << i : int | 0 <= i /\ i < size | s[i] >>
    } 
    /* a procedures and functions */
 
    proc readString(inout str : String)
      {pre  true  pre}
      {post str.s != null post}
      |[ if str.s != null -> free(str.s) 
         [] otherwise -> skip
         fi;
         str.s := readln(&str.size);
      ]|
    
    proc writeString(in str : String)
      {pre  str.s != null  pre}
      {post true post}
      |[ var i := 0 : int;
        if (str.s == null) -> skip
        [] otherwise ->
            {inv str.s[i] == '\0' ==> i == str.size inv}
            {bound str.size - i  bound}
            do i < str.size /\ str.s[i] != '\0' ->
              write(str.s[i]);
              i := i+1;
            od
        fi

      ]|
    proc copy(ref str : String, in s : char*)
      {pre  true  pre}
      {post true post}
      |[ var i := 0 : int;
         var m : Mem(char);

        if (str.s == null) -> skip
        [] otherwise -> free(str.s); str.s := null;
        fi;

        {inv true inv}
        {bound MAX_INT - str.size  bound}
        do s[str.size] != '\0' ->
          str.size := str.size+1;
        od;

        malloc(m, str.size, str.s);

        {inv s[i] == '\0' ==> i == str.size inv}
        {bound str.size - i  bound}
        do i < str.size /\ s[i] != '\0' ->
          str.s[i] := s[i];
          i := i+1;
        od;
      ]|

    proc concat(in str1 : String, in str2 : String, inout str_out : String)
      {pre  str1.s != null /\ str2.s != null  pre}
      {post (% forall i : int 
                | 0 <= i /\ i < str1.size 
                | str1.s[i] == str_out.s[i] %) 
        /\  (% forall i : int 
                | 0 <= i /\ i < str2.size 
                | str2.s[i] == str_out.s[i+str1.size] %) 
      post}
      |[  var i := 0 : int;
          var m : Mem(char);
          var c := str_out.s : char*;
          str_out.size := str1.size + str2.size;
          malloc (m, str_out.size + 1, str_out.s);
          
          {inv str1.s[i] == '\0' ==> i == str1.size inv}
          {bound str1.size - i  bound}
          do i < str1.size /\ str1.s[i] != '\0' ->
            str_out.s[i] := str1.s[i];
            i := i+1;
          od;

          i := 0;
          {inv str2.s[i] == '\0' ==> i == str2.size inv}
          {bound str2.size - i  bound}
          do i < str2.size /\ str2.s[i] != '\0' ->
            str_out.s[i+str1.size] := str2.s[i];
            i := i+1;
          od;
          free(c);
          str_out.s[str_out.size+1] := '\0'
      ]|
  end
end