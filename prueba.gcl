
 /*% LANGUAGE MemoryOperations %*/
 /*% LANGUAGE EnableTrace %*/
 /*% LANGUAGE LogicAnywhere %*/

include "hola"
include "chao"

program Program.bin begin


enum Y {
  Javier2 := 4,
  Carlos2 := 2
}

abstract SS(B) begin var s : sequence of B; {repinv true repinv} end

type S(T) implements SS(int)
begin
  /* S variables */
  var Hope : T;
  
  {repinv true repinv}

  {coupinv true coupinv}

  where {
    s := <<1,2,3,4>>
  }
  
  /* S procedures and functions */
  proc c(inout s : S(T), in e : T)
    {pre  true  pre}
    {post true post}
    |[
      s.Hope := e;
    ]|        
end


alias GG := S(int*);

proc name (in x : array[3] of int)
  
  |[
    write(x[2]);
    x[1] := 10;
  ]|        

func _trace (x : float) -> float
  |[
    1.0
  ]|

main |[
  var __x__ : int;
  var x-r
  var f : float;
  var p,q : int*;
  // var i := 0 : int;
  // var y,z : float*;
  // var file := "hola" : char*;
  var Q : GG;
  // var p1, p2 : array[3] of int;
  // var a3 : array[2,3] of array[2,2] of array[3,2] of int;
  // p1[0], p1[1], p1[2] := 100,2,3;
  // writeln(">>> ", __x__ + 10 );
  // writeln(p1[0]);
  // writeln(p1[1]);
  // writeln(p1[2]);
  // write("<<<");
  
  // p := [int*](&p1)+ 1;
  // q := [int*](&p2)+1;
  // y := [float*]q;
  // z := [float*]p;
  // *y := *z;

  // write(">>> ");
  // writeln(p2[0]);
  // writeln(p2[1]);
  // writeln(p2[2]);
  // write("<<<");
  
  new(p);
  // name(p1);
  // *p := 1010101;
  // c(Q,p);
  // writeln("es? > ", *Q.Hope);
  // read(x,f,i) from "file";
  // writeln(">> ", *p);
  // writeln(x);
  // writeln(f);
  // writeln(i);
  writeln(">>", A);
  writeln(">>", B);
  writeln(">>", C);
  writeln(">>", D);
  writeln(">>", E);
  writeln(">>", F);
  writeln(">>", G);
  // free(Q.Hope);
  // writeln(">>", H);
  // x := p[0];
]|
end